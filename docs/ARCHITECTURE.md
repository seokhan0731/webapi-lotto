# java-webapi-lotto
---

# 아키텍처 및 설계 보고서

---

## #1. 전체 구조

로또 게임이라는 복잡한 로직을 체계적으로 관리하기 위해, 기능별로 나눈 후, 각 기능에서의 코드를 4가지 계층으로 구분했습니다.

* **Controller**: 사용자의 요청을 DTO로 형식으로 받아, 요청에 대한 결과값을 DTO로 포장하여 응답합니다.
* **Service**: POJO 클래스를 이용하여 핵심 비즈니스 로직을 수행합니다.
* **Repository**: 데이터베이스에 데이터를 저장하거나 불러옵니다.
* **Domain**
    * POJO: 기존 콘솔 로또 프로젝트에서 사용되었던 코드로, API 요청과는 관계없이 순수한 로직을 수행합니다.
    * Entity: Repository에서 관리하는 객체로, 데이터베이스 로직의 대상이 됩니다.

---

## #2. 패키지 구조

기능별 구성을 큰 뼈대로 잡고 설계하였으며, 여러 기능에서 사용되는 코드들은 별도의 패키지로 분리했습니다.

* **기능별 구성**
    * purchase: 로또 구매 관련 로직이 수행되는 패키지입니다.
    * mylotto: 구매한 로또에 대한 발행 로직이 수행되는 패키지입니다.
    * winninglotto: 당첨 로또 관련 로직이 수행되는 패키지입니다.
    * bonusnumber: 보너스 번호 관련 로직이 수행되는 패키지입니다.
    * result: 로또 게임의 결과 관련 로직이 수행되는 패키지입니다.
* **그 외 패키지 구성**
    * globalexceptionhandler: Controller 계층 내, 에러 메시지를 가로채어 처리하는 패키지입니다.
      여러 Controller 계층에서 @ExceptionHandler를 통해, 에러 메시지를 반환하는 로직이 중복되어, 별도의 패키지로 분리하였습니다.
    * singlelottosuperentity: 단일 로또에 해당하는 Entity를 POJO로 변환하는 작업을 처리하는 패키지입니다.
      보너스 번호와 당첨 번호와의 중복 확인, 결과 계산을 위한 POJO로의 변환 과정에서, 로직이 중복되어, 별도의 패키지로 분리하였습니다.
    * pojo: 기존 콘솔 로또 프로젝트에서 사용되었던 코드가 위치한 패키지입니다.
      각 기능에서 하나 이상의 POJO가 사용되는 경우가 존재하여, 별도의 pojo 패키지로 분리하였습니다.

```text
precourse.openmission
├──globalexceptionhandler
├──singlelottosuperentity
├──pojo
│
├──purchase     //기능별 패키지 구조 예시
│    ├──dto
│    │   ├──PurchaseRequestDTO.java
│    │   └──PurchaseResponseDTO.java
│    ├──PurchaseController.java 
│    ├──PurchaseService.java 
│    ├──PurchaseRepository.java 
│    └──Purchase.java       //Entity
│
├──mylotto
├──winninglotto
├──bonusnumber
└──result
```

**참고**: 모든 기능 패키지는 위와 동일한 계층 구조를 따르지만, 입력 데이터가 필요없는 경우, RequestDTO는 존재하지 않습니다.
또한 데이터베이스에 접근할 필요가 없는 기능의 경우, Repository계층과 Entity는 존재하지 않습니다.

---

## #3. 데이터베이스 설계

* Purchase:MyLotto
    * 관계: 1:n
    * 하나의 구매 내역에 여러 장의 로또가 발행되어 연결됩니다.
* Purchase:WinningLotto
    * 관계: 1:1
    * 당첨 로또는 특정 회차의 구매내역에 종속되어야 하므로, Purchase의 PK(Id)를 공유합니다.
* Purchase:BonousNumber
    * 관계: 1:1
    * 보너스 번호는 특정 회차의 구매내역에 종속되어야 하므로, Purchase의 Pk(Id)를 공유합니다.

**의도**: 단일 횟수의 로또 결과를 구하는 것이 아닌, 여러 회차의 로또 결과를 구하기 위해, 로또 게임에서 가장 먼저 선행되는 구매 기능의 고유한
Id필드를 통해, 여러 회차의 게임 구성요소들을 구분하고자, 이러한 관계를 설정하여 구현하였습니다.

---

## #4. 기술적 의사결정

프로젝트 진행 중 마주친 기술적 고민과 그에 대한 최종 결정을 정리했습니다.

* **결과 데이터 저장 여부**
    * 고민: 결과 데이터를 데이터베이스에 저장하여, 조회 요청시, 데이터베이스에서 값을 조회할 것인지 고민했습니다.
    * 최종 결정: 조회 요청시, 실시간을 결과 데이터를 계산하여 반환하도록 구현했습니다.
    * 이유: 구매한 로또, 당첨 로또, 보너스 번호 등은 각각 독립적으로 존재하는 데이터이기 때문에, 최종 계산을 위해, 데이터베이스에 필수적으로
      저장되어야 하지만, 결과 데이터는 이 요소들로부터 언제든 도출될 수 있는 데이터이기 때문에, 실시간으로 계산하는 방식이 옳다고 생각했습니다.
* **POJO와 Entity 분리**
    * 고민: 구현 전, 참고했던 대부분의 자료들은 하나의 Entity 내부에서, 로직을 수행하는 경우가 대부분이었기 때문에, 하나의 Entity를 
        Domain계층으로 설정하여, 구현할 것인지, 기존 POJO를 Domain 계층에 추가시킬 것인지 고민했습니다.
    * 최종 결정: Entity는 단순한 데이터베이스 로직의 객체로, 실제 비즈니스 로직은 POJO에서 수행하도록 구현했습니다.
    * 이유: 여러 객체와 상호작용을 해야 하는 작업(Ex. 당첨 번호와의 중복 체크)을 Entity에서 수행하게 한다면, 하나의 Entity 객체가 
       짊어지는 책임이 무거워진다고 생각했기에, 전체 프로젝트 구조가 커진다하더라도, POJO를 Domain 계층에 추가시키는 것이 옳다고 생각했습니다.