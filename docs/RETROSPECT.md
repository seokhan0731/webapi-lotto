# java-webapi-lotto
---

# 회고록

---

## #1. 프로젝트 선정 배경

제가 우아한 테크코스를 지원한 이유는 단순히 시키는 것만 구현하는 개발자가 아닌 모든 과정을 주도적으로 장악할 수 있는
개발자가 되고 싶기 떄문입니다.
이에 따라, 처음 오픈 미션 설명회를 듣고, 저는 주저 없이 Spring Boot 웹 API 개발을 목표로 삼았습니다.
해당 주제가 모든 것을 내 손으로 설계하고 구현하는 백엔드 개발인 만큼, 제가 꿈꾸는 모습으로 성장하기 위한 출발점이라 확신했습니다.

제가 '주도적인 개발'을 원하게 된 계기는 지난 학기 팀 프로젝트에서의 아쉬움 때문이었습니다. 당시 Django를 사용한 웹서비스를 개발하는 팀 프로젝트
진행했었는데, 저는 거대한 웹 어플리케이션이 돌아가는 원리를 모른 채 데이터베이스에 필요한 내용 찾은 후, 채우기와 같은 주변부 작업을 수행하는
역할에 머물러야 했습니다. 팀원들이 핵심 로직을 설계하고 구현할 때, 저는 그저 완성된 결과를 관찰할 수 밖에 없었던 제 한계에 깊은 좌절감과
주도적인 개발자가 되고 싶다는 갈증을 느꼈습니다.

그렇기에 이번 오픈 미션을 통해 궁극적으로 이루고자 하는 목표는 하나였습니다. 겉으로 드러나는 화려한 UI나 커다란 규모의 프로젝트 보다는,
죽이 되든, 밥이 되든 제가 직접 처음부터 끝까지 구현하고, 그 과정에서 백엔드의 기본적인 흐름을 내 것으로 소화하는 것이었습니다.
이에 따라, 프로젝트의 규모를 키우기 보다, 오픈 미션 전까지 학습해왔던 단위 기능 TDD 개발 방식으로 개발된 단단한 프로젝트를 개발하기로 마음
먹었습니다.
제가 새로운 주제가 아닌 기존의 '로또 미션'을 재선정한 이유도 바로 여기에 있습니다. 이미 검증된 로직을 사용함으로써, 아낀 시간과 에너지를 모두
백엔드의 본질을 깨닫는데 쏟고 싶었기 때문입니다.

---

## #2. 프로젝트 진행 과정

### 2-1. 애플리케이션 개발 전

애플리케이션을 개발하기 전, 백엔드와 Spring Boot에 대한 학습을 먼저 선행하기로 마음 먹었습니다. 처음 백엔드나, Spring Boot에 대한
자료나 강의 영상을 3~4일 동안 보며, 기본적인 개념들을 머리로 이해하려 노력했습니다. REST API, DI에 대한 지식들을 이해하는게 어렵지 않았지만,
막상 나의 프로젝트에 코드로 적용해보려고 하니, 어떻게 시작해야 할지 감도 안 잡히고 엄두도 나지 않았습니다. 이론과 실전 사이의 괴리감 속에서,
단순히 강의를 완강하는 것 자체가 목적이 되어가고 있다는 위기감을 느꼈습니다.

이에 저는 학습 전략을 180도 수정했습니다. 완벽한 학습을 선행 후, 구현을 시작하고자 했던 기존 계획을 버리고, 일단 도전해보자는 마음으로 IDE를
켜고, 학습 자료 속 코드 구조를 그대로 따라 작성하며 개발을 시작하게 되었습니다.

### 2-2. 애플리케이션 개발 중

개발을 시작하고, 가장 처음 마주한 난관은 구조의 복잡성이었습니다. 대부분의 자료들은, Controller, Domain(Entity), Service, Repository
로 나누어진 상태에서 시작이 되었지만, 기존 '로또 미션'에서 작성했던 코드들을 어떠한 구조로 활용할 지를 결정했어야 했고, 이 지점에서 꽤 오랜 시간
고민했습니다. 처음에는 남들처럼 Entity 안에 로직을 다 옮겨야 하나 싶었지만, 그러기엔 각각의 Entity에게 너무 무거운 책임을 주는 것 같기도 했고,
'로또 미션'에서 잘 돌아가는 것이 검증된 기존 로직을 굳이 망가뜨리고 싶지 않았습니다.
그래서 저는 Domain 계층을 Entity와 POJO로 나누어, POJO에서 모든 비즈니스 로직을 부담하고, Entity는 단순한 데이터베이스의 저장되는 객체로만
사용하기로 결심했습니다. 모든 구현을 마친 상태에서, 돌이켜보면 이 방식을 선택한 탓에 다시 Entity로 기존 로직을 이식 하는 과정이 없었어도 됐고,
데이터베이스 연결을 하지 않은 상태에서 순수 자바 코드로만 테스트할 수 있다는 점에서 잘한 결정이었다고 생각이 듭니다.

비슷한 맥락에서, 패키지 구조와 계층 분리에 대한 고민도 있었습니다. '로또 게임'이라는 작은 애플리케이션 하나를 구현하는데도, 굳이 기능별 패키지로
분리 후, 기능마다 계층 설계를 하는 것이 잘하는 짓인가라는 의문이 개발을 하면서도 들었었습니다.
하지만 저는 이번 프로젝트의 목표는 결국 백엔드의 기본을 확실히 얻어가는 것에 두었기 때문에, 비록 작은 애플리케이션의 작은 기능일지라도 내 손으로
직접 계층 구조로 설계하고 작성하는 것이 더 도움이 될 것이라 생각했습니다. 돌이켜보면 이런 식으로 설계하고 구현하지 않았다면, 더 빨리 프로젝트를
마무리 지었을 수 있었겠지만, 지금 수준만큼으로 얻어 가지는 못했을 것이라고 확신합니다.

구조를 잡고 어느 방향으로 진행할 지가 정해진 뒤, 데이터를 저장하는 단계에서 또 다른 난관을 만났습니다. 처음에 데이터베이스를 모델링 할때, 어렴풋이
여러 차수의 로또 게임을 진행할 수 있도록 구매 내역의 고유값을 통해 엮어야겠다는 생각을 했지만, 이것을 구체적인 관계로 정의하는 것이 어려웠습니다.
이를 해결하기 위해, 인터넷에서 외래키 개념과 테이블 간 관계 자료를 찾아보고, 학습하는 과정에서 모호하게만 알고 있던 외래키에 대한 개념을 확실히
잡을 수 있었고, @MapsId를 통해 어떻게 정의되는지에 대해서도 알 수 있게 되었습니다.

하지만 진짜 난관은 테스트 코드로 구현하는 과정에서 찾아왔습니다. 영속성 문제와 마주쳤을 때, 분명 로직에는 문제가 없는데, 테스트 코드가 실패하는
현상은 당시의 저로서는 도저히 이해할 수 없는 미지의 영역이었습니다. 여태까지 접해본 에러와는 결이 다른 에러였기 때문에, 에러로그를 인터넷에
검색해보고 영속성, 컨텍스트, 트랜잭션에 대한 개념부터 이해하는 것이 너무 낯설었고, 이해하는 데도 가장 시간이 오래 걸렸던 것 같습니다. 그 과정에서
JPA가 단순히 쿼리문을 날려주는 도구가 아니라 객체의 생명주기와도 밀접한 연관이 있는 시스템임을 깨달았고, 단순히 백엔드 작업이라는 것이 로직만
작성하는 것이 아닌, 프레임워크의 편리함 속 이면의 동작 원리를 알고, 이를 고려하여 코드를 설계하고 작성해야한다는 교훈을 얻게 되었습니다.

이렇게 내부 로직과 데이터 설계 과정을 넘긴 후면, 고비가 없을 줄 알았지만, API 통합 테스트를 처음 작성하는 과정에서도 난관을 마주치게 되었습니다.
TDD를 구현 방식으로 구현하고자 했기 때문에, 테스트를 해야했지만, API 단계에서의 TDD 자료가 많이 없었고, HTTP 프로토콜, 상태코드, JSON 등의
지식도 완벽하지 않았던 탓에, 솔직히 고백하자면, 테스트 코드를 한 줄도 적지 못한 채 손만 놓고 있었습니다. 도저히 감이 잡히지 않아, 결국 강의자료
속 RestAssured 기반 코드를 그대로 복사해서 붙여넣고 돌려보는 것부터 시작했습니다. 이후, 제일 간단한 구매 기능 API 테스트부터 시작해, 복사한
코드를 제 프로젝트의 코드에 맞게 하나씩 뜯어고치며 분석했습니다. 이때, 막연하게만 느껴지던 API 관련 지식들이 실제 코드와 매핑되며 머릿속에
들어오기 시작했고, 이 경험이 더 복잡한 기능에 대한 테스트 코드를 스스로 설계하고 작성할 수 있게 만들었던 것 같습니다.

### 2-3. 애플리케이션 개발 후

초기의 목표는 웹 API의 기능 구현까지였습니다. 기능 구현이 생각보다 빠르게 마무리가 되어, 남은 시간을 어떻게 활용해야 가장 의미가 있을지 깊이
고민했습니다. 기능 추가, 간단한 UI 구현을 해볼까 싶었지만, 처음에 설정했던 목표에 맞추어 기능 구현 이후의 작업을 경험하기로 결정했습니다.
이에 지속적 통합(CI)/지속적 배포(CD) 중, 하나를 경험해보기로 했고, 그중에서도 저는 배포보다는 검증에 기반한 통합이 우선이라는 결론을 내렸습니다.
프리코스 기간 동안, 테스트 코드의 중요성에 대해 몸소 느껴서 그랬던 것 같기도 하지만, 검증되지 않은 코드를 무리하게 배포하기 보다는, 검증된
코드의 우선순위가 더 높다고 생각하여, CI 작업을 해보기로 최종 결정을 내렸습니다.

사실 CI에 대해 처음 작업을 시도했을 때, 기능을 구현하기 시작할 때와는 다르게 겁이 나지 않았습니다. 모든 개별 테스트 코드들을 통과한
상태였기 때문에, 각각의 코드는 기능적으로 완벽하고, 단순히 설정 파일만 작업하면 모든 작업이 끝일 것이라고 생각했습니다. 하지만 첫 설정 파일을
작성한 후의, 첫 결과는 저의 이런 생각을 변화시켜주었습니다.

이벤트 시점을, master 브랜치에 Pull Request 작업을 수행할 때 전체 테스트를 진행하는 것으로 설정한 후, 당연히 통과될 것으로 생각했던
Pull Request는 실패했고, 이때, 내 컴퓨터에서 돌아가는 코드와 어디서든 돌아가는 코드는 완전히 다르다는 사실을 깨닫게 되었습니다. 처음에는
단순히 코드 오류라고 생각했지만, 로그를 분석해보니 원인은 코드가 아닌 환경에 있었습니다. 로컬 환경에서는 당연하게 여겼던 데이터베이스 연결
설정이, 텅 빈 CI 서버에서는 당연한 것이 아니였습니다. 이때, 단순히 로직만 완벽하다고 끝나는 것이 아닌, 코드가 실행되는 환경까지 고려하고
제어하는 과정도 필요하다는 것을 몸소 느꼈습니다.

---

## #3. 마무리

오픈 미션이 다 끝난 시점에, 누군가 저에게 초기에 설정했던 목표를 이루었는지 묻는다면, 저는 자신있게 그렇다고 답할 것입니다.
물론 이게 최선의 설계인지, 최선의 코드인지는 확신할 수 없지만, 해당 오픈 미션 기간동안, 후회는 남지 않을 정도로 도전하고,
몰입하고 이루었던 것 같습니다. 상당히 작은 프로젝트지만, 모든 프로젝트 과정을 제 손으로 직접 설계하고 구현하며 전체 사이클을 온전히 스스로의
힘으로 해봤다는 점에서 의미가 있었던 것 같습니다. 이 과정 속에서, 초기의 목표였던 백엔드에 대한 기본기는 당연히 이루었으며, 이번 경험은 앞으로
개발자의 꿈을 이어나갈 때, 제가 목표로 하는 모든 과정을 주도적으로 장악할 수 있는 개발자로 성장하는 데 큰 밑거름이 되어줄 것이라 확신합니다.
이번 프로젝트는 끝이 났지만, 저의 목표에 대한 여정은 이제 막 시작되었습니다. 이번 오픈 미션에서 얻어간 것을 발판 삼아, 끊임 없이 도전하고 몰입
하여 꿈꾸는 개발자의 모습으로 성장하겠습니다.